from grid import Grid


class GridSolver:
    def __init__(self, grid, obstacles):
        self.grid = grid
        self.heuristic = grid.euclidean_distance_2d
        self.g_cost_per_step = 1
        self.obstacles = obstacles

    def visualize_path(self, path):
        """
        Visualize the path in the grid; path is represented by 'o', start by 'S', goal by 'G', and obstacles by 'x'
        :param path: List, a list of locations on a grid (e.g. generated by GridSolver.a_star()[0])
        :return:
        """
        for y in range(self.grid.grid_y_length):
            for x in range(self.grid.grid_x_length):
                if (x, y) == self.grid.get_start():
                    print('S ', end='')
                elif (x, y) == self.grid.get_goal():
                    print('G ', end='')
                elif (x, y) in path:
                    print('o ', end='')
                elif (x, y) in self.obstacles:
                    print('x ', end='')
                else:
                    print('. ', end='')
            print()

    def visualize_obstacle(self, obstacles):
        """
        Visualize the obstacles in the grid; obstacles are represented by 'x'
        :param obstacles: set, a set of locations on a grid
        :return:
        """
        for y in range(self.grid.grid_y_length):
            for x in range(self.grid.grid_x_length):
                if (x, y) in obstacles:
                    print('x ', end='')
                else:
                    print('. ', end='')
            print()

# ------------------------------------ Optimal Algorithms ------------------------------------

    def a_star(self):
        """
        A* algorithm that takes in a grid, a heuristic, a start state, and a goal state, and returns a path from the
        start state to the goal state if possible; and False is returned if otherwise
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        # Initialize the current state to the initial state
        current_state = self.grid.get_start()
        # Initialize the current path to the initial state
        current_path = [current_state]
        # Initialize the current g-cost to 0
        current_g_cost = 0
        # Initialize the current cost to the heuristic cost of the initial state
        current_h_cost = self.heuristic(current_state, self.grid.get_goal())
        current_f_cost = current_g_cost + current_h_cost

        # While the current state is not the goal state
        while current_state != self.grid.get_goal():
            # Get the successors of the current state
            successors = self.grid.get_successors(current_state=current_state,
                                                  obstacles=self.obstacles)

            # Initialize the successor with the lowest cost to the first successor
            successor_with_lowest_cost = successors[0]
            # Initialize the lowest cost to the cost of the successor with the lowest cost
            lowest_cost = self.heuristic(successor_with_lowest_cost, self.grid.get_goal())

            # For each successor
            for successor in successors[1:]:  # Skip the first successor since it's already been initialized
                # If the cost of the successor is less than the lowest cost
                if self.heuristic(successor, self.grid.get_goal()) < lowest_cost:
                    # Set the successor with the lowest cost to the successor
                    successor_with_lowest_cost = successor
                    # Set the lowest cost to the cost of the successor
                    lowest_cost = self.heuristic(successor, self.grid.get_goal())

            # Set the current state to the successor with the lowest cost
            current_state = successor_with_lowest_cost

            if current_state in current_path:
                raise ValueError('Path is not possible, current state has been expanded twice')
            # Add the current state to the current path
            else:
                current_path.append(current_state)
            # Set the current h-cost to the lowest cost (we can do this because g-cost is always 1!)
            current_h_cost = lowest_cost
            # Set the current g-cost to the current g-cost plus 1 (due to the nature of our movement: no diagonal edges)
            current_g_cost += self.g_cost_per_step
            # Set the current f-cost to the current g-cost plus the current h-cost
            current_f_cost = current_g_cost + current_h_cost

        # Return the current path and the current cost
        return current_path, current_f_cost

    def greedy_best_first_search(self):
        """
        Greedy best-first search algorithm that takes in a grid, a heuristic, a start state, and a goal state, and
        returns a path from the start state to the goal state if possible; and False is returned if otherwise
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        # Initialize the current state to the initial state
        current_state = self.grid.get_start()
        # Initialize the current path to the initial state
        current_path = [current_state]
        # Greedy BFS only has a heuristic cost, so we don't need a g-cost
        # Initialize the current cost to the heuristic cost of the initial state
        current_h_cost = self.heuristic(current_state, self.grid.get_goal())

        # While the current state is not the goal state
        while current_state != self.grid.get_goal():
            # Get the successors of the current state
            successors = self.grid.get_successors(current_state=current_state,
                                                  obstacles=self.obstacles)

            # Initialize the successor with the lowest cost to the first successor
            successor_with_lowest_cost = successors[0]
            # Initialize the lowest cost to the cost of the successor with the lowest cost
            lowest_cost = self.heuristic(successor_with_lowest_cost, self.grid.get_goal())

            # For each successor
            for successor in successors[1:]:
                # If the cost of the successor is less than the lowest cost
                if self.heuristic(successor, self.grid.get_goal()) < lowest_cost:
                    # Set the successor with the lowest cost to the successor
                    successor_with_lowest_cost = successor
                    # Set the lowest cost to the cost of the successor
                    lowest_cost = self.heuristic(successor, self.grid.get_goal())

            # Set the current state to the successor with the lowest cost
            current_state = successor_with_lowest_cost

            if current_state in current_path:
                raise ValueError('Path is not possible, current state has been expanded twice')
            # Add the current state to the current path
            else:
                current_path.append(current_state)
            # Set the current h-cost to the lowest cost (we can do this because g-cost is always 1!)
            current_h_cost = lowest_cost

        # Return the current path and the current cost (we don't need to return h-cost as it is always 0,
        # but we do it for consistency among the different algorithms' outputs)
        return current_path, current_h_cost

    def iterative_deepening_a_star(self):
        """
        Iterative deepening A* search algorithm that takes in a grid, a heuristic, a start state, and a goal state, and
        returns a path from the start state to the goal state if possible; and False is returned if otherwise
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        # Initialize the current state to the initial state
        current_state = self.grid.get_start()
        # Initialize the current path to the initial state
        current_path = [current_state]
        # Initialize the current g-cost to 0
        current_g_cost = 0
        # Initialize the current cost to the heuristic cost of the initial state
        current_h_cost = self.heuristic(current_state, self.grid.get_goal())
        current_f_cost = current_g_cost + current_h_cost

        # Initialize the current depth to 0
        current_depth = 0
        # Initialize the depth of the goal to infinity
        goal_depth = float('inf')

        # While the current state is not the goal state
        while current_state != self.grid.get_goal():
            # Get the successors of the current state
            successors = self.grid.get_successors(current_state=current_state,
                                                  obstacles=self.obstacles)

            # Initialize the successor with the lowest cost to the first successor
            successor_with_lowest_cost = successors[0]
            # Initialize the lowest cost to the cost of the successor with the lowest cost
            lowest_cost = self.heuristic(successor_with_lowest_cost, self.grid.get_goal())

            # For each successor
            for successor in successors[1:]:
                # If the cost of the successor is less than the lowest cost
                if self.heuristic(successor, self.grid.get_goal()) < lowest_cost:
                    # Set the successor with the lowest cost to the successor
                    successor_with_lowest_cost = successor
                    # Set the lowest cost to the cost of the successor
                    lowest_cost = self.heuristic(successor, self.grid.get_goal())

            # If the current depth is greater than or equal to the goal depth
            if current_depth >= goal_depth:
                # Return False, as the goal is unreachable
                return False
        # Return the current path and the current cost (we don't need to return h-cost as it is always 0,
        # but we do it for consistency among the different algorithms' outputs)
        return current_path, current_f_cost


# ------------------------------------ Suboptimal Algorithms ------------------------------------
    """
    The weight is a parameter that can be adjusted to change the behavior of the algorithm. A weight of 1 is 
     equivalent to A* search. A weight greater than 1 will cause the algorithm to favor a greedy approach in terms
        of reducing the heuristic, and vice versa for a weight less than 1.
    """
    def weighted_a_star(self, weight):
        """
        Weighted A* algorithm that takes in a grid, a heuristic, a start state, and a goal state, and returns a path
        from the start state to the goal state if possible; and False is returned if otherwise
        :param: weight: float, a weight to be applied to the heuristic
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        # Initialize the current state to the initial state
        current_state = self.grid.get_start()
        # Initialize the current path to the initial state
        current_path = [current_state]
        # Initialize the current g-cost to 0
        current_g_cost = 0
        # Initialize the current cost to the heuristic cost of the initial state
        current_h_cost = self.heuristic(current_state, self.grid.get_goal())
        current_f_cost = current_g_cost + current_h_cost

        # While the current state is not the goal state
        while current_state != self.grid.get_goal():
            # Get the successors of the current state
            successors = self.grid.get_successors(current_state=current_state,
                                                  obstacles=self.obstacles)

            # Initialize the successor with the lowest cost to the first successor
            successor_with_lowest_cost = successors[0]
            # Initialize the lowest cost to the cost of the successor with the lowest (weighted) cost
            lowest_cost = current_g_cost + weight*self.heuristic(successor_with_lowest_cost, self.grid.get_goal())

            # For each successor
            for successor in successors[1:]:  # Skip the first successor since it's already been initialized
                # If the cost of the successor is less than the lowest cost, note here we apply weight to the heuristic
                if current_g_cost + weight*self.heuristic(successor, self.grid.get_goal()) < lowest_cost:
                    # Set the successor with the lowest cost to the successor
                    successor_with_lowest_cost = successor
                    # Set the lowest cost to the cost of the successor
                    lowest_cost = current_g_cost + weight*self.heuristic(successor, self.grid.get_goal())

            # Set the current state to the successor with the lowest cost
            current_state = successor_with_lowest_cost

            if current_state in current_path:
                raise ValueError('Path is not possible; current state has been expanded twice')
            # Add the current state to the current path
            else:
                current_path.append(current_state)
            # Set the current h-cost to the lowest cost
            current_h_cost = lowest_cost
            # Set the current g-cost to the current g-cost plus 1 (due to the nature of our movement/no diagonal edges)
            current_g_cost += self.g_cost_per_step
            # Set the current f-cost to the current g-cost plus the current h-cost
            current_f_cost = current_g_cost + current_h_cost

        # Return the current path and the current cost
        return current_path, current_f_cost


