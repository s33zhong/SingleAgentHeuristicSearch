from grid import Grid
import heapq
from queue import PriorityQueue


class GridSolver:
    def __init__(self, grid: Grid, obstacles):
        self.grid = grid
        self.heuristic = grid.euclidean_distance_2d
        self.g_cost_per_step = 1
        self.obstacles = obstacles

    def visualize_path(self, path):
        """
        Visualize the path in the grid; path is represented by 'o', start by 'S', goal by 'G', and obstacles by 'x'
        :param path: List, a list of locations on a grid (e.g. generated by GridSolver.a_star()[0])
        :return:
        """
        for y in range(self.grid.grid_y_length):
            for x in range(self.grid.grid_x_length):
                if (x, y) == self.grid.get_start():
                    print('S ', end='')
                elif (x, y) == self.grid.get_goal():
                    print('G ', end='')
                elif (x, y) in path:
                    print('o ', end='')
                elif (x, y) in self.obstacles:
                    print('x ', end='')
                else:
                    print('. ', end='')
            print()

    def visualize_obstacle(self):
        """
        Visualize the obstacles in the grid; obstacles are represented by 'x'
        :return:
        """
        for y in range(self.grid.grid_y_length):
            for x in range(self.grid.grid_x_length):
                if (x, y) in self.obstacles:
                    print('x ', end='')
                else:
                    print('. ', end='')
            print()

    @staticmethod
    def index_in_open_list(state, open_list):
        """
        Check if a state is in the open list, a heapq-based priority queue.
        This method is very slow unfortunately, as we need to iterate through the entire list to check for membership.
        :param state:     tuple, a state (location) on the grid
        :param open_list: list, a heapq-based priority queue
        :return:          int, index of item if found and -1 otherwise
        """
        for item_index in range(len(open_list)):  # starts from 0 so we are safe returning -1
            if open_list[item_index][1] == state:
                return item_index
        return -1

    def solve(self, algorithm='greedy_best_first_search'):
        if algorithm == 'greedy_best_first_search':
            return self.greedy_best_first_search()

    # ------------------------------------ Optimal Algorithms ------------------------------------

    def greedy_best_first_search(self):
        """
        greedy_best_first_search algorithm that takes in a grid, a heuristic, a start state, and a goal state,
          and returns a path from the start state to the goal state if possible; and False is returned if otherwise
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        # Initialize the current state to the initial state
        current_state = self.grid.get_start()
        # Initialize the current cost to the heuristic cost of the initial state
        current_f_cost = self.heuristic(current_state, self.grid.get_goal())
        # Initialize the closed list to be empty
        closed_list = dict()  # We need to store the parent! Sets do not suffice. Keys -> states, Values -> parents
        # Initialize the open list to contain the initial state; we use heapq to implement the priority queue
        open_list = []
        heapq.heappush(open_list, (current_f_cost, current_state))
        max_iter = 20
        iteration = 0
        while len(open_list) > 0 \
                and iteration < max_iter:  # while the open list is not empty, we can continue expanding states
            iteration += 1
            last_state = current_state  # store the last state for updating the closed list
            # pop the state with the lowest f-cost from the open list
            expanded_state = heapq.heappop(open_list)
            current_f_cost, current_state = expanded_state[0], expanded_state[1]
            print('Current f cost: ', current_f_cost)
            closed_list[current_state] = last_state  # add the current state to the closed list
            successors = self.grid.get_successors(current_state, obstacles=self.obstacles)
            print('Current state: ', current_state)
            if not successors:
                print('Expanding a state with no successors! Current state: ', current_state)
            else:
                for successor in successors:
                    if successor == self.grid.get_goal():
                        closed_list[successor] = current_state  # add the current state to the closed list
                        # If the successor is the goal, return the path from the initial state to the goal state
                        path = [successor]
                        parent = closed_list[successor]
                        start = self.grid.get_start()
                        while parent != start:
                            path.append(parent)
                            parent = closed_list[parent]
                        path.append(start)
                        path.reverse()
                        return path, current_f_cost
                    # print('Successor: ', successor)
                    index_in_open_list = self.index_in_open_list(successor, open_list)
                    # If the successor is not in the closed list and not in the open list, add it to the open list
                    #   and set the parent of the successor to the current state
                    # print('Index in open list: ', index_in_open_list)
                    if successor in closed_list.keys():  # successor in closed list
                        continue
                    elif index_in_open_list == -1:
                        successor_f_cost = self.heuristic(successor, self.grid.get_goal())
                        # Add the successor to the open list; we are using heapq to implement the priority queue
                        heapq.heappush(open_list, (successor_f_cost, successor))
                        # print('Added successor to open list: ', successor)
                    # If the successor is in the open list, check if the current f-cost is lower than the f-cost of the
                    #   successor; if so, update the f-cost of the successor and set the parent of the successor to the
                    #   current state.
                    elif index_in_open_list != -1:
                        # print('Successor in open list: ', successor)
                        # print('Open list: ', open_list)
                        # If the current g-cost is lower than the g-cost of the successor, update the f-cost of the
                        #   successor and set the parent of the successor to the current state
                        if current_f_cost < self.heuristic(successor, self.grid.get_goal()):
                            heapq.heappush(open_list, (current_f_cost, successor))
                            print('Updated f-cost of successor: ', successor)
                        else:
                            # print('Not a better path to successor: ', successor)
                            continue
            print('------------------------------------')
            print('Open list: ', open_list)
            print('Closed list: ', closed_list)
            print('------------------------------------')

        # If the open list is empty, return False; path is impossible or the algorithm has failed (which theoretically
        #   should not happen)
        return False, False

    # def greedy_best_first_search(self):
    #     """
    #     Greedy best-first search algorithm that takes in a grid, a heuristic, a start state, and a goal state, and
    #     returns a path from the start state to the goal state if possible; and False is returned if otherwise
    #     :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
    #                  or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
    #     """
    #     pass

    def iterative_deepening_a_star(self):
        """
        Iterative deepening A* search algorithm that takes in a grid, a heuristic, a start state, and a goal state, and
        returns a path from the start state to the goal state if possible; and False is returned if otherwise
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        pass

    # ------------------------------------ Suboptimal Algorithms ------------------------------------
    """
    The weight is a parameter that can be adjusted to change the behavior of the algorithm. A weight of 1 is 
     equivalent to A* search. A weight greater than 1 will cause the algorithm to favor a greedy approach in terms
        of reducing the heuristic, and vice versa for a weight less than 1.
    """

    def weighted_a_star(self, weight):
        """
        Weighted A* algorithm that takes in a grid, a heuristic, a start state, and a goal state, and returns a path
        from the start state to the goal state if possible; and False is returned if otherwise
        :param: weight: float, a weight to be applied to the heuristic
        :return: either: a tuple of a list of states (locations on the grid) and the cost of the path
                     or: ValueError, if a path is impossible (unreachable goal, detected by re-expansion of states)
        """
        pass
